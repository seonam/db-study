
오라클 기준으로 보면, JDBC array size(보통 fetch size / row prefetch)는 결과를 몇 건만 조회할지를 정하는 스펙이 아니다. 
이 값은 한 번의 왕복(round trip) 에서 결과를 몇 행씩 미리 가져와 클라이언트 버퍼에 쌓아둘지를 정하는 값이다.


오라클 JDBC는 기본적으로 커서 기반으로 결과를 읽으며, 기본적으로 10행씩 가져오는 동작이 기본값으로 알려져 있고, 이 기본값은 row-prefetch(defaultRowPrefetch)라는 개념으로 설명된다. 
오라클 문서에서 기본적으로 커서에서 10행씩 받는다(기본 row-prefetch)라고 명시하고, row-prefetch 값을 바꾸면 커서로부터 각 왕복마다 받아오는 행 수가 바뀐다고 설명한다. 
또한 오라클 JDBC 는 defaultRowPrefetch 를 커넥션 속성으로도 노출하며, 이는 OracleConnection#setDefaultRowPrefetch 호출과 동일하다고 문서에 적혀 있다.
(JDBC 표준의 setFetchSize(n)는 “제한”이 아니라 힌트 성격이라 드라이버가 무시/조정할 여지도 있다. 다만 오라클 드라이버는 row-prefetch 기능으로 꽤 직접적으로 매핑되는 편이다.)


오라클에서 SELECT * FROM member 같은 쿼리를 실행하면 결과 전체를 만들어서 한 번에 던져주는게 아니라, 서버 쪽에 실행 상태를 가진 커서(서버 커서)가 생성된다. 
클라이언트(JDBC)는 이 커서를 앞으로 전진시키면서(fetch) 결과 행을 받아온다. 애플리케이션 코드에서 ResultSet.next()를 호출한다는 건, 개념적으로 커서에서 다음 행을 달라는 요청을 반복하는 것과 같다. 
다만 이때의 next()는 호출 1번당 네트워크 왕복 1번이 아니라, 드라이버 버퍼에 프리페치된 행이 남아 있으면 그걸 즉시 꺼내 주고, 버퍼가 고갈되면 그 시점에 커서로부터 다음 배치를 가져오는 왕복이 발생하는 모델이다. 이게 row-prefetch/fetch size 가 가지는 의미이다.


여기서 array size = 100이라고 하면, DB가 100건만 조회하고 끝내는게 아니다. 드라이버가 next()를 100번 호출할 때마다 서버에 매번 왕복하지 않도록, 서버 커서로부터 다음 행들을 미리 묶어서 받아 드라이버 내부 버퍼에 저장한다. 그 다음부터는 next() 호출이 올 때마다 버퍼에서 한 행씩 꺼내 반환한다. 버퍼가 소진되면, 그 다음 next() 시점에 드라이버가 다시 서버로 왕복해서 다음 100행을 추가로 fetch 해 버퍼를 채운다. 즉 array size는 **“전송/버퍼링 단위”**다. 오라클이 이를 “round trip을 줄여 성능을 개선한다”는 목적으로 문서화한 것도 같은 맥락이다.
(주의: “서버가 100행을 미리 만들어서 보낸다”는 표현은 결과적으로 맞지만, 내부적으로는 정렬/조인/필터링 등 실행계획에 따라 서버가 row source에서 행을 생산해 커서를 통해 흘려보내는 방식이라, 어떤 쿼리는 초반부터 행이 잘 나오고 어떤 쿼리는 늦게 나오기도 한다. row-prefetch는 어디까지나 전송 묶음 크기다.)


따라서 DBMS는 몇 행까지 읽었냐는 질문은 커서 관점에서 답해야 한다. 첫 fetch에서 100행을 프리페치했다면, 애플리케이션이 아직 20행만 처리했더라도 서버 커서는 이미 100행까지 진행했을 수 있다.
다만 애플리케이션 메모리에 올라와 대기 중인 행은 보통 드라이버 버퍼(남은 80행)와 현재 처리 중인 행 정도다. 이 구조 때문에 결과가 커도 애플리케이션이 한 번에 전부를 객체로 만들지 않는 것이 가능해진다. 
이때 중요한 포인트는 프리페치된 80행은 DB row를 그대로 들고 있는 게 아니라, 드라이버/프레임워크가 각 행의 컬럼을 읽어 객체로 만들기 전 단계로 보관하는 경우가 많고(드라이버 버퍼), 반대로 JPA처럼 엔티티를 만들어 List에 담아버리면 그 순간부터는 자바 객체가 메모리를 지배한다는 점이다.


JPA나 Querydsl을 사용해 memberRepository.findAll()처럼 List<Member>를 받는 경우에도, 내부에서는 결국 JDBC가 제공하는 ResultSet을 순회하며 행을 읽고 엔티티를 만들어 리스트에 담는다. 
차이는 개발자가 rs.next()를 직접 작성하지 않는다는 점뿐이다. 

예를 들어 Hibernate 쪽에는 결과를 읽어 List에 추가하는 루프가 있고, rowProcessingState.next()를 돌면서 results.add(...)를 수행한다. 
즉 next로 한 행씩 전진 → 읽기 → List에 담기 라는 본질이 유지된다. 
Querydsl도 최종적으로는 JPA Query를 만들고 getResultList()로 결과를 받아 List를 리턴하는 구조라, List를 리턴하는 순간 전체를 담는다는 계약이 같다. 
(Querydsl JPA의 AbstractJPAQuery#fetch()가 createQuery() 후 getResultList(...)로 끝나는 흐름이 그대로 보인다.)

반대로 JdbcTemplate.query(...)는 RowMapper를 주면 rs.next() 루프를 내부에서 돌며 리스트를 만들어주고, RowCallbackHandler 같은 방식을 쓰면 한 행씩 콜백으로 받아 처리하면서 누적을 피할 수 있다. 
즉, ResultSet은 사라진 게 아니라 프레임워크 뒤로 숨겨진 것이다. 

Spring의 RowMapperResultSetExtractor는 각 row를 RowMapper로 매핑하고 results List에 추가한다고 API 문서에 적혀 있고, 실제로 while (rs.next()) { results.add(rowMapper.mapRow(...)) } 형태의 구현이 존재한다. 
또한 JdbcTemplate 자체가 query(sql, RowCallbackHandler)를 RowCallbackHandlerResultSetExtractor로 감싸서 호출하는 코드가 공개돼 있다. 
즉 루프는 템플릿 내부, 처리는 콜백 모델이 맞다.


## 참고
[Oracle JDBC: 기본 10행 row-prefetch, fetch size / round trip 설명]
- Fetch Size (기본 10행, row-prefetch): https://docs.oracle.com/cd/A97335_02/apps.102/a83724/resltse5.htm
- Oracle Row Prefetching (round trip 줄이기): https://docs.oracle.com/cd/A97335_02/apps.102/a83724/oraperf2.htm
- defaultRowPrefetch 속성 = setDefaultRowPrefetch: https://docs.oracle.com/en/database/oracle/oracle-database/21/jjdbc/data-sources-and-URLs.html

[Spring JDBC: JdbcTemplate이 루프를 숨긴다(코드/Extractor)]
- JdbcTemplate 소스: https://github.com/spring-projects/spring-framework/blob/main/spring-jdbc/src/main/java/org/springframework/jdbc/core/JdbcTemplate.java
- RowMapperResultSetExtractor API(각 row를 List에 추가): https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/RowMapperResultSetExtractor.html
- RowMapperResultSetExtractor 소스: https://github.com/spring-projects/spring-framework/blob/master/spring-jdbc/src/main/java/org/springframework/jdbc/core/RowMapperResultSetExtractor.java
  (while (rs.next()) … results.add(…))
- JdbcTemplate API(공식 Javadoc): https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html

[Hibernate ORM: next로 List에 담는 코드]
- OutputsImpl 소스(while rowProcessingState.next() … results.add …): https://github.com/hibernate/hibernate-orm/blob/master/hibernate-core/src/main/java/org/hibernate/result/internal/OutputsImpl.java

[Querydsl JPA: fetch() → createQuery() → getResultList()]
- AbstractJPAQuery 소스: https://github.com/querydsl/querydsl/blob/master/querydsl-jpa/src/main/java/com/querydsl/jpa/impl/AbstractJPAQuery.java
